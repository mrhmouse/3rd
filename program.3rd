: dup2 dup dip dup rot swap ;
: dip2 dip dip;
: when [] swap if ;
: unless [] dip2 if ;
: drop2 drop drop ;
: drop3 drop2 drop ;
: NL "\n" . ;
: p . NL ;
: show dup p ;
: neg dup 2 * - ;
: each [drop2]
       [dup dip pop dip call swap each]
       [swap dup empty dip swap]
       if ;
: while
  # Call the condition
  dup2 swap call dip swap

  # Call the body and re-arrange
  [dip dup dip swap call
   dip swap while]

  # Get rid of the body & condition
  [dip drop swap drop]

  # Just read the result from calling
  # the condition earlier
  [] if
;
: iota () swap <iota> ;
: <iota> [drop] [dup dip swap push swap 1 - <iota>] [dup 0 =] if ;

# Count down from 5
# (5 4 3 2 1) [. NL] each

100000 iota [drop] each
